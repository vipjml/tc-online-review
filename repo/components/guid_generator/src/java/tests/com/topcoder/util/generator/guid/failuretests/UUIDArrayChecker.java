/**
 * Copyright &copy 2004, TopCoder, Inc. All rights reserved.
 */
package com.topcoder.util.generator.guid.failuretests;

import com.topcoder.util.generator.guid.*;

import junit.framework.Assert;

import java.net.InetAddress;

import java.util.HashSet;


/**
 * This is a helper class for checking a UUID array for various properties, including NotNull checking,Uniqueness
 * checking ,Variant and Version checking for 128-bit implementation.
 *
 * <p>
 * Copyright &copy 2004, TopCoder, Inc. All rights reserved.
 * </p>
 *
 * @author TCSDEVELOPER
 * @version 1.0
 */
public class UUIDArrayChecker {
    /**
     * This method check whether there is some null instance in the array.
     *
     * @param ids id array to be checked
     */
    public static void checkNotNull(UUID[] ids) {
        for (int index = 0; index < ids.length; index++) {
            Assert.assertNotNull("ids[" + index + "] is null.", ids[index]);
        }
    }

    /**
     * This method check general presentaion(length, etc) of all instances in the array.
     *
     * @param ids id array to be checked
     */
    public static void checkPresentation(UUID[] ids) {
        for (int index = 0; index < ids.length; index++) {
            Assert.assertEquals("byte array of id is in incorrect length.",
                ids[index].getBitCount() / 8, ids[index].toByteArray().length);
        }
    }

    /**
     * This method check uniqueness of all instances in the array.
     *
     * @param ids id array to be checked
     */
    public static void checkUniqueness(UUID[] ids) {
        // here we'll assert that all elements in the list are not equal to
        // each other (there should be no duplicates) we'll do this by
        // inserting all elements into a HashSet and making sure none of them
        // were already present (add will return false if it was already there)
        HashSet set = new HashSet();

        for (int index = 0; index < ids.length; index++) {
            Assert.assertTrue(
                "Uniqueness test failed on insert id into HashSet " + index,
                set.add(ids[index].toString()));
            Assert.assertFalse("Paranoia Uniqueness test failed (second insert) on insert id into HashSet",
                set.add(ids[index].toString()));
        }
    }

    /**
     * This method check variant field and version field for 128-bit UUID format.
     *
     * @param ids id array to be checked
     * @param version expected version
     */
    public static void checkVariantAndVersion(UUID[] ids, int version) {
        for (int index = 0; index < ids.length; index++) {
            // if not 128-bit uuid, skip immediately
            if (!(ids[index] instanceof UUID128Implementation)) {
                continue;
            }

            byte[] bytes = ids[index].toByteArray();

            // extract version field
            int ver = (bytes[6] & 0xff) >> 4;
            Assert.assertEquals("ids[" + index +
                "] is with incorrect version field.", version, ver);

            // extract variant field
            int var = (bytes[8] & 0xff) >> 6;
            Assert.assertEquals("ids[" + index +
                "] is with incorrect variant field.", 2, var);
        }
    }

    /**
     * This method check the validity of creation timestamps for 128-bit UUID generated by version1.
     *
     * @param ids id array to be checked
     * @param startTime time before id array generating
     * @param endTime time after id array generating
     */
    public static void checkCreationTime(UUID[] ids, long startTime,
        long endTime) {
        // we need to convert from 100-naonsecond units (as used in UUIDs)
        // to millisecond units as used in UTC based time
        final long MILLI_CONVERSION_FACTOR = 10000L;

        Assert.assertTrue("start time" + startTime +
            " was not before the end time " + endTime, startTime <= endTime);

        // let's check that all uuids in the array have a timestamp which lands
        // between the start and end time
        for (int index = 0; index < ids.length; index++) {
            byte[] temp_uuid = ids[index].toByteArray();

            // first we'll collect the UUID time stamp which is
            // the number of 100-nanosecond intervals since
            // 00:00:00.00 15 October 1582
            long uuid_time = 0L;
            uuid_time |= ((temp_uuid[3] & 0xF0L) << 0);
            uuid_time |= ((temp_uuid[2] & 0xFFL) << 8);
            uuid_time |= ((temp_uuid[1] & 0xFFL) << 16);
            uuid_time |= ((temp_uuid[0] & 0xFFL) << 24);
            uuid_time |= ((temp_uuid[5] & 0xFFL) << 32);
            uuid_time |= ((temp_uuid[4] & 0xFFL) << 40);
            uuid_time |= ((temp_uuid[7] & 0xFFL) << 48);
            uuid_time |= ((temp_uuid[6] & 0x0FL) << 56);

            // and convert to milliseconds as the system clock is in millis
            uuid_time /= MILLI_CONVERSION_FACTOR;

            // now check that the times are correct
            Assert.assertTrue("Start time: " + startTime +
                " was not before UUID timestamp: " + uuid_time,
                startTime <= uuid_time);
            Assert.assertTrue("UUID timestamp: " + uuid_time +
                " was not before the start time: " + endTime,
                uuid_time <= endTime);
        }
    }

    /**
     * This method check the validity of IEEE Address for 128-bit UUID generated by version1.
     *
     * @param ids id array to be checked
     */
    public static void checkIEEEAddress(UUID[] ids) {
    	try {
	        byte[] ipAddress = InetAddress.getLocalHost().getAddress();

	        for (int index = 0; index < ids.length; index++) {            
	            if (ipAddress.length != 4) {
	                // local ip address is not IPv4 address, we believe randomized
	                // value has been set properly.
	            } else {
	                // check ip address
	                for (int offset = 0; offset < ipAddress.length; offset++) {
	                    Assert.assertTrue("IEEE Address of ids[" + index +
	                        "]is incorrect.",
	                        (ipAddress[offset] == ids[index].toByteArray()[12 +
	                        offset]));
	                }
	            }
	            
	        }
    	} catch (Exception exp) {
    		// ignored.
    	}
    }
}
