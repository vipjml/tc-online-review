package com.topcoder.util.compression;

/**
 * <p>This class encapsulates a byte array holding data and an associated
 * "lookback" window of previous data. It manages the complexity of
 * maintaining this lookback window correctly as input is added, and copying
 * sections of previous input to current input.</p>
 *
 * <p>Copyright &copy; 2003, TopCoder Inc. All rights reserved.</p>
 *
 * @author  TCSDESIGNER
 * @version 1.0
 */
final class ByteArrayWithLookback {

    private static final byte[] EMPTY_LOOKBACK = new byte[0];

    private final int lookbackSize;
    private byte[] lookback;
    private byte[] buffer;
    private int offset;
    private int length;

    /**
     * <p>Creates a <code>ByteArrayWithLookback</code> with a lookback
     * window of a given size.</p>
     *
     * @param lookbackSize lookback window size in bytes
     */
    ByteArrayWithLookback(final int lookbackSize) {
        if (lookbackSize <= 0) {
            throw new IllegalArgumentException();
        }
        this.lookbackSize = lookbackSize;
        this.lookback = EMPTY_LOOKBACK;
    }

    /**
     * <p>Sets the current input byte array. Note that
     * {@link #saveLookback(int)} should be called first to update the
     * lookback window first, before this method sets a new input
     * byte array.</p>
     *
     * @param buffer new byte array
     * @param offset index of first byte of data in array
     * @param length number of bytes of data in array
     * @see   #saveLookback(int)
     */
    void setNextBuffer(final byte[] buffer,
                       final int offset,
                       final int length) {
        if (buffer == null) {
            throw new IllegalArgumentException();
        }
        if (offset < 0 || offset + length > buffer.length) {
            throw new ArrayIndexOutOfBoundsException();
        }
        this.buffer = buffer;
        this.offset = offset;
        this.length = length;
    }

    /**
     * <p>Copies bytes from behind the current input position to the
     * current input position. This handles cases where some or all of
     * the data to copy comes from the lookback window and/or the current
     * input buffer as well.</p>
     *
     * <p>Note that <code>lookbackOffset</code> is an offset backwards
     * from <code>bufferOffset</code>, not forwards from the start of the
     * window.</p>
     *
     * @param  lookbackOffset offset backwards from <code>bufferOffset</code>
     *                        to start copying from
     * @param  bufferOffset   offset into buffer to copy to
     * @param  copyLength     number of bytes to copy
     * @throws ArrayIndexOutOfBoundsException if <code>bufferOffset</code> is
     *  before the input array's <code>offset</code>, or
     *  <code>bufferOffset + copyLength</code> exceeds the end of the input
     *  array, or <code>copyLength</code> exceeds <code>lookbackOffset</code>
     */
    void copyFromLookbackToBuffer(final int lookbackOffset,
                                  final int bufferOffset,
                                  final int copyLength) {
        if (bufferOffset < offset
                || bufferOffset + copyLength > offset + length
                || copyLength > lookbackOffset) {
            throw new ArrayIndexOutOfBoundsException();
        }

        if (copyLength > 0) {
            if (bufferOffset - lookbackOffset >= offset) {
                // Copy entirely from buffer
                copy(buffer,
                     bufferOffset - lookbackOffset,
                     buffer,
                     bufferOffset,
                     copyLength);
            } else {
                final int availableInBuffer = bufferOffset - offset;
                if (lookbackOffset - copyLength < availableInBuffer) {
                    // Copy spans both lookback and current buffer

                    final int toCopyFromLookback =
                        lookbackOffset - availableInBuffer;
                    final int toCopyFromBuffer =
                        copyLength - toCopyFromLookback;
                    copy(lookback,
                         lookback.length - toCopyFromLookback,
                         buffer,
                         bufferOffset,
                         toCopyFromLookback);
                    copy(buffer,
                         offset,
                         buffer,
                         bufferOffset + toCopyFromLookback,
                         toCopyFromBuffer);
                } else {
                    // Copy comes entirely from lookback
                    copy(lookback,
                         lookback.length - (lookbackOffset - availableInBuffer),
                         buffer,
                         bufferOffset,
                         copyLength);
                }

            }
        }

    }

    /**
     * <p>Updates the lookback window to hold the most recent bytes of data,
     * and clears the input buffer. This handles the cases where some of
     * the saved data also comes from the current lookback window. Also,
     * the entire input buffer is not necessarily saved (since not necessarily
     * all of it was processed); the <code>bufferLengthToSave</code> parameter
     * controls how many bytes to save.</p>
     *
     * @param bufferLengthToSave number of bytes of input to save, at most
     */
    void saveLookback(final int bufferLengthToSave) {

        // if there is any current buffer to save
        if (buffer != null) {

            // if there is more than enough data in the buffer
            if (bufferLengthToSave > lookbackSize) {
                // no need to also save from the current lookback;
                // keep part of the current buffer as lookback
                lookback = new byte[lookbackSize];
                copy(buffer,
                     offset + bufferLengthToSave - lookbackSize,
                     lookback,
                     0,
                     lookback.length);
            } else {

                if (lookback.length + bufferLengthToSave > lookbackSize) {
                    final byte[] newLookback = new byte[lookbackSize];
                    final int toCopyFromLookback =
                            bufferLengthToSave > lookbackSize
                            ? 0
                            : lookbackSize - bufferLengthToSave;
                    if (toCopyFromLookback > 0) {
                        // copy some of lookback and all of current buffer
                        // into new lookback
                        copy(lookback,
                             lookback.length - toCopyFromLookback,
                             newLookback,
                             0,
                             toCopyFromLookback);
                        copy(buffer,
                             offset,
                             newLookback,
                             toCopyFromLookback,
                             bufferLengthToSave);
                    } else {
                        copy(buffer,
                             offset + bufferLengthToSave - lookbackSize,
                             newLookback,
                             0,
                             lookbackSize);
                    }
                    lookback = newLookback;

                } else {
                    // copy all of lookback and current buffer into
                    // new lookback
                    final byte[] newLookback = new byte[lookback.length + bufferLengthToSave];
                    copy(lookback,
                         0,
                         newLookback,
                         0,
                         lookback.length);
                    copy(buffer,
                         offset,
                         newLookback,
                         lookback.length,
                         bufferLengthToSave);
                    lookback = newLookback;
                }
            }

            buffer = null;
            offset = 0;
            length = 0;
        }
        // else nothing to do -- but hold on to current lookback, in case
    }

    /**
     * <p>Clears all internal data structures, both lookback and input
     * buffer.</p>
     */
    void clear() {
        buffer = null;
        lookback = EMPTY_LOOKBACK;
        offset = 0;
        length = 0;
    }

    private static void copy(final byte[] src,
                             final int srcPosition,
                             final byte[] dest,
                             final int destPosition,
                             final int length) {
        if (length > 0) {
            if (length == 1) {
                // Don't bother with native call if just copying one byte;
                // this is the common case
                dest[destPosition] = src[srcPosition];
            } else {
                System.arraycopy(src, srcPosition, dest, destPosition, length);
            }
        }
    }
}package com.topcoder.util.compression;

import java.util.zip.Deflater;
import java.util.zip.Inflater;

/**
 * <p>Implementations of <code>Codec</code> encapsulate <code>Deflater</code> /
 * <code>Inflater</code> pairs, which together represent compression and
 * decompression functionality for a particular algorithm.</p>
 *
 * <p>Note that the <code>Deflater</code>s and <code>Inflater</code>s
 * produced by implementations may not be thread-safe.</p>
 *
 * <p>Copyright &copy; 2003, TopCoder Inc. All rights reserved.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 */
public interface Codec {

    /**
     * <p>Returns <code>Deflater</code> that encapsulates compression
     * functionality for this <code>Codec</code>'s algorithm.</p>
     *
     * @return <code>Deflater</code> that encapsulates compression
     *  functionality for this <code>Codec</code>'s algorithm.
     */
    Deflater createDeflater();

    /**
     * <p>Returns <code>Inflater</code> that encapsulates decompression
     * functionality for this <code>Codec</code>'s algorithm.</p>
     *
     * @return <code>Inflater</code> that encapsulates decompression
     *  functionality for this <code>Codec</code>'s algorithm.
     */
    Inflater createInflater();

}
package com.topcoder.util.compression;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.zip.Deflater;
import java.util.zip.Inflater;
import java.util.zip.DataFormatException;

/**
 * <p>This utility class provides access to compression and decompression
 * functionality. Callers can use this class with various <code>Codec</code>
 * implementations, which encapsulate compression/decompression algorithms.
 * Data can be compressed and decompressed to and from files and streams.</p>
 *
 * <p>Copyright &copy; 2003, TopCoder Inc. All rights reserved.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 * @see     Codec
 */
public class CompressionUtility {

    /**
     * <p>Size of block of input data processed at each step during
     * compression.</p>
     */
    private static final int COMPRESS_BUFFER_SIZE = 2048;

    /**
     * <p>Size of block of input data processed at each step during
     * decompression. It is a multiple of 3 for the benefit of the
     * {@link LZ77Decoder}, whose compressed format consists of
     * triplets of bytes.</p>
     */
    private static final int DECOMPRESS_BUFFER_SIZE =
        COMPRESS_BUFFER_SIZE - (COMPRESS_BUFFER_SIZE % 3);

    protected Codec codec;
    protected OutputStream outputStream;
    protected InputStream inputStream;

    // Constructors ----------------------------------------------------------

    /**
     * <p>Constructs a new <code>CompressionUtility</code> that utilizes
     * the named <code>Codec</code>. Output is written to the given
     * <code>OutputStream</code>.</p>
     *
     * @param  className fully-qualified name of <code>Codec</code>
     *         implementation to use
     * @param  output stream to write output to
     * @throws IllegalArgumentException if either <code>className</code> or
     *  <code>output</code> is <code>null</code>
     * @throws ClassNotFoundException if the class cannot be located
     * @throws InstantiationException  if the class is an
     *  abstract class, an interface, an array class, a primitive type, or
     *  void; or if the instantiation fails for some other reason
     * @throws IllegalAccessException if the class or initializer is
     *  not accessible
     * @throws LinkageError if the linkage fails
     * @throws ExceptionInInitializerError if the initialization provoked
     *  by this method fails
     * @since  1.0
     */
    public CompressionUtility(final String className,
                              final OutputStream output)
            throws ClassNotFoundException, InstantiationException,
            IllegalAccessException {
        if (className == null) {
            throw new IllegalArgumentException("Class name cannot be null");
        }
        if (output == null) {
            throw new IllegalArgumentException("Output cannot be null");
        }
        initialize(className, output);
    }

    /**
     * <p>Constructs a new <code>CompressionUtility</code> that utilizes
     * the named <code>Codec</code>. Output is written to the given file.</p>
     *
     * @param  className fully-qualified name of <code>Codec</code>
     *         implementation to use
     * @param  output file to write output to
     * @throws IllegalArgumentException if either <code>className</code> or
     *  <code>output</code> is <code>null</code>
     * @throws FileNotFoundException if the given output file does not exist
     * @throws ClassNotFoundException if the class cannot be located
     * @throws InstantiationException  if the class is an
     *  abstract class, an interface, an array class, a primitive type, or
     *  void; or if the instantiation fails for some other reason
     * @throws IllegalAccessException if the class or initializer is
     *  not accessible
     * @throws LinkageError if the linkage fails
     * @throws ExceptionInInitializerError if the initialization provoked
     *  by this method fails
     * @since  1.0
     */
    public CompressionUtility(final String className, final File output)
            throws ClassNotFoundException, InstantiationException,
            IllegalAccessException, FileNotFoundException {
        if (className == null) {
            throw new IllegalArgumentException("Class name cannot be null");
        }
        if (output == null) {
            throw new IllegalArgumentException("Output file cannot be null");
        }
        initialize(className, new FileOutputStream(output));
    }

    /**
     * <p>Constructs a new <code>CompressionUtility</code> that utilizes
     * the named <code>Codec</code>. Output is written to the given
     * <code>StringBuffer</code>; bytes are converted into characters
     * according to the default character encoding, and then appended
     * to the <code>StringBuffer</code>.</p>
     *
     * @param  className fully-qualified name of <code>Codec</code>
     *         implementation to use
     * @param  output <code>StringBuffer</code> to write output to
     * @throws IllegalArgumentException if either <code>className</code> or
     *  <code>output</code> is <code>null</code>
     * @throws ClassNotFoundException if the class cannot be located
     * @throws InstantiationException  if the class is an
     *  abstract class, an interface, an array class, a primitive type, or
     *  void; or if the instantiation fails for some other reason
     * @throws IllegalAccessException if the class or initializer is
     *  not accessible
     * @throws LinkageError if the linkage fails
     * @throws ExceptionInInitializerError if the initialization provoked
     *  by this method fails
     * @since  1.0
     */
    public CompressionUtility(final String className,
                              final StringBuffer output)
            throws ClassNotFoundException, InstantiationException,
            IllegalAccessException {
        if (className == null) {
            throw new IllegalArgumentException("Class name cannot be null");
        }
        if (output == null) {
            throw new IllegalArgumentException("Output cannot be null");
        }
        initialize(className, new StringBufferOutputStream(output));
    }

    private void initialize(final String className,
                            final OutputStream outputStream)
            throws ClassNotFoundException, InstantiationException,
            IllegalAccessException {
        // Constructors call this method instead of each other, since each
        // needs to check illegal arguments first, instead of calling
        // "this()"
        this.codec = createCodec(className);
        this.outputStream = outputStream;
    }

    /**
     * <p>Returns an instance of the indicated <code>Codec</code>
     * implementation.</p>
     *
     * @param  className fully-qualified name of <code>Codec</code>
     *         implementation to use
     * @throws IllegalArgumentException if <code>className</code> is
     *  <code>null</code>, or does not name a class that implements
     *  <code>Codec</code>
     * @throws ClassNotFoundException if the class cannot be located
     * @throws InstantiationException  if the class is an
     *  abstract class, an interface, an array class, a primitive type, or
     *  void; or if the instantiation fails for some other reason
     * @throws IllegalAccessException if the class or initializer is
     *  not accessible
     * @throws LinkageError if the linkage fails
     * @throws ExceptionInInitializerError if the initialization provoked
     *  by this method fails
     * @return an instance of the named <code>Codec</code> implementation
     */
    public static Codec createCodec(final String className)
            throws ClassNotFoundException, InstantiationException,
            IllegalAccessException {
        if (className == null) {
            throw new IllegalArgumentException("Class name cannot be null");
        }
        final Object codec = Class.forName(className).newInstance();
        if (!(codec instanceof Codec)) {
            throw new IllegalArgumentException(className + " is not a Codec");
        }
        return (Codec) codec;
    }


    // Compression methods --------------------------------------------------

    /**
     * <p>Initiates compression of the data from the given input stream.</p>
     *
     * @param  input stream whose data is to be compressed
     * @throws IllegalArgumentException if <code>input</code> is
     *  <code>null</code>
     * @throws IOException if an I/O exception occurs while compressing,
     *  either while reading or writing data
     */
    public void compress(final InputStream input) throws IOException {
        if (input == null) {
            throw new IllegalArgumentException("Input stream cannot be null");
        }
        this.inputStream = input;
        compress();
    }

    /**
     * <p>Initiates compression of the data from the given file.</p>
     *
     * @param  input to compress
     * @throws IllegalArgumentException if <code>input</code> is
     *  <code>null</code>
     * @throws IOException if an I/O exception occurs while compressing,
     *  either while reading or writing data
     * @throws FileNotFoundException if the given input file does not exist
     */
    public void compress(final File input) throws IOException {
        if (input == null) {
            throw new IllegalArgumentException("Input file cannot be null");
        }
        this.inputStream = new FileInputStream(input);
        compress();
        this.inputStream.close();
    }

    /**
     * <p>Initiates compression of the data from the given
     * <code>StringBuffer</code>. Its characters are converted to bytes
     * according to the default character encoding, and compressed.</p>
     *
     * @param  input <code>StringBuffer</code> to compress
     * @throws IllegalArgumentException if <code>input</code> is
     *  <code>null</code>
     * @throws IOException if an I/O exception occurs while compressing,
     *  while writing data
     */
    public void compress(final StringBuffer input) throws IOException {
        if (input == null) {
            throw new IllegalArgumentException("Input cannot be null");
        }
        compress(new ByteArrayInputStream(input.toString().getBytes()));
    }


    // Decompression methods ------------------------------------------------

    /**
     * <p>Initiates decompression of the data from the given input stream.</p>
     *
     * @param  input stream whose data is to be decompressed
     * @throws IllegalArgumentException if <code>input</code> is
     *  <code>null</code>
     * @throws IOException if an I/O exception occurs while decompressing,
     *  either while reading or writing data
     * @throws DataFormatException if the input data is not valid
     */
    public void decompress(final InputStream input)
            throws IOException, DataFormatException {
        if (input == null) {
            throw new IllegalArgumentException("Input stream cannot be null");
        }
        this.inputStream = input;
        decompress();
    }

    /**
     * <p>Initiates decompression of the data from the given file.</p>
     *
     * @param  input file to decompress
     * @throws IllegalArgumentException if <code>input</code> is
     *  <code>null</code>
     * @throws IOException if an I/O exception occurs while decompressing,
     *  either while reading or writing data
     * @throws FileNotFoundException if the given input file does not exist
     * @throws DataFormatException if the input data is not valid
     */
    public void decompress(final File input)
            throws IOException, DataFormatException {
        if (input == null) {
            throw new IllegalArgumentException("Input file cannot be null");
        }
        this.inputStream = new FileInputStream(input);
        decompress();
        this.inputStream.close();
    }

    /**
     * <p>Initiates decompression of the data from the given
     * <code>StringBuffer</code>. Its characters are converted to bytes
     * according to the default character encoding, and decompressed.</p>
     *
     * @param  input <code>StringBuffer</code> to decompress
     * @throws IllegalArgumentException if <code>input</code> is
     *  <code>null</code>
     * @throws IOException if an I/O exception occurs while decompressing,
     *  while writing data
     * @throws DataFormatException if the input data is not valid
     */
    public void decompress(final StringBuffer input)
            throws IOException, DataFormatException {
        if (input == null) {
            throw new IllegalArgumentException("Input cannot be null");
        }
        decompress(new ByteArrayInputStream(input.toString().getBytes()));
    }

    /**
     * <p>Closes the underlying <code>OutputStream</code>.</p>
     *
     * @throws IOException if an I/O exception occurs while closing the stream
     */
    public void close() throws IOException {
        this.outputStream.flush();
        this.outputStream.close();
    }

    /**
     * <p>Worker method that compresses all data from the internal
     * <code>InputStream</code> and writes it to the internal
     * <code>OutputStream</code>, using this object's <code>Codec</code>.</p>
     *
     * @throws IOException if an I/O exception occurs while compressing,
     *  while reading or writing data
     */
    protected void compress() throws IOException {
        final Deflater deflater = codec.createDeflater();
        final byte[] in  = new byte[COMPRESS_BUFFER_SIZE];
        final byte[] out = new byte[COMPRESS_BUFFER_SIZE];

        int bytesRead;
        while ((bytesRead = inputStream.read(in)) > 0) {
            deflater.setInput(in, 0, bytesRead);
            if (bytesRead < in.length) {
                // last buffer
                deflater.finish();
            }
            // Keep encoding until input is exhausted, since it's possible
            // that it does not compress into the allocated buffer during
            // the first pass
            int bytesEncoded;
            while ((bytesEncoded = deflater.deflate(out)) > 0) {
                outputStream.write(out, 0, bytesEncoded);
            }
        }
        deflater.end();
    }

    /**
     * <p>Worker method that decompresses all data from the internal
     * <code>InputStream</code> and writes it to the internal
     * <code>OutputStream</code>, using this object's <code>Codec</code>.</p>
     *
     * @throws IOException if an I/O exception occurs while decompressing,
     *  while reading or writing data
     * @throws DataFormatException if the input data is not valid
     */
    protected void decompress() throws IOException, DataFormatException {
        final Inflater inflater = codec.createInflater();
        final byte[] in  = new byte[DECOMPRESS_BUFFER_SIZE];
        final byte[] out = new byte[DECOMPRESS_BUFFER_SIZE];

        int bytesRead;
        while ((bytesRead = inputStream.read(in)) > 0) {
            inflater.setInput(in, 0, bytesRead);
            // Keep decoding until input is exhausted, since it's possible
            // that it does not decompress into the allocated buffer during
            // the first pass
            int bytesDecoded;
            while ((bytesDecoded = inflater.inflate(out)) > 0) {
                outputStream.write(out, 0, bytesDecoded);
            }
        }
        inflater.end();
    }

}
package com.topcoder.util.compression;

import java.util.zip.Deflater;
import java.util.zip.Inflater;

/**
 * <p>Default <code>Codec</code> implementation that returns Java's
 * <code>Deflater</code> and <code>Inflater</code> objects; this implementation
 * thus supports encoding and decoding of the ZIP and GZIP formats.</p>
 *
 * <p>Copyright &copy; 2003, TopCoder Inc. All rights reserved.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 */
public class DefaultCodec implements Codec {

    /**
     * <p>Returns a new <code>Deflater</code> object.</p>
     *
     * @return a new <code>Deflater</code> object
     */
    public Deflater createDeflater() {
        return new Deflater();
    }

    /**
     * <p>Returns a new <code>Inflater</code> object.</p>
     *
     * @return a new <code>Inflater</code> object
     */
    public Inflater createInflater() {
        return new Inflater();
    }

}
package com.topcoder.util.compression;

import java.util.zip.Deflater;
import java.util.zip.Inflater;

/**
 * <p><code>Codec</code> implementation that provides and implementation of
 * the original Lempel-Ziv (LZ77) compression algorithm.</p>
 *
 * <p>Note that the <code>Deflater</code>s and <code>Inflater</code>s
 * produced by this implementation are not thread-safe.</p>
 *
 * <p>Copyright &copy; 2003, TopCoder Inc. All rights reserved.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 * @see     <a href="http://www.free2code.net/tutorials/other/20/LZ77.php">
 *          LZ77 tutorial</a>
 */
public class LZ77Codec implements Codec {

    /** Maximum size of lookback window used during encoding / decoding. */
    static final int WINDOW_SIZE = 256;

    /**
     * <p>Returns a new <code>LZ77Encoder</code> object.</p>
     *
     * @return a new <code>LZ77Encoder</code> object
     */
    public Deflater createDeflater() {
        return new LZ77Encoder();
    }

    /**
     * <p>Returns a new <code>LZ77Decoder</code> object.</p>
     *
     * @return a new <code>LZ77Decoder</code> object
     */
    public Inflater createInflater() {
        return new LZ77Decoder();
    }

}
package com.topcoder.util.compression;

import java.util.zip.Inflater;
import java.util.zip.DataFormatException;

/**
 * <p>This subclass of <code>Inflater</code> overrides its methods to implement
 * decompression according to the Lempel-Ziv (LZ77) algorithm.</p>
 *
 * <p>Note that this class is not thread-safe.</p>
 *
 * <p>Copyright &copy; 2003, TopCoder Inc. All rights reserved.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 * @see     <a href="http://www.free2code.net/tutorials/other/20/LZ77.php">
 *          LZ77 tutorial</a>
 */
public class LZ77Decoder extends Inflater {

    /** Maximum size of lookback window used during decoding. */
    private static final int WINDOW_SIZE = LZ77Codec.WINDOW_SIZE;

    private byte[] inputBytes;
    private int inputPosition;
    private int inputMax;
    private final ByteArrayWithLookback output;
    private int totalIn;
    private int totalOut;

    /**
     * <p>Creates a new <code>LZ77Decoder</code>.</p>
     */
    public LZ77Decoder() {
        output = new ByteArrayWithLookback(WINDOW_SIZE);
    }

    /**
     * <p>Sets input data for decompression. This should be called whenever
     * {@link #needsInput()} returns <code>true</code> indicating that more
     * input data is required.</p>
     *
     * <p>Note that if <code>offset + length</code> exceeds the length of
     * the input array, no exception will be thrown, but only bytes through
     * the end of the array will be processed.</p>
     *
     * @param  inputBytes the input data bytes
     * @throws NullPointerException if input is <code>null</code>
     */
    public void setInput(final byte[] inputBytes) {
        if (inputBytes == null) {
            throw new NullPointerException("Input bytes cannot be null");
        }
        setInput(inputBytes, 0, inputBytes.length);
    }

    /**
     * <p>Sets input data for decompression. This should be called whenever
     * {@link #needsInput()} returns <code>true</code> indicating that more
     * input data is required.</p>
     *
     * <p>Note that if <code>offset + length</code> exceeds the length of
     * the input array, no exception will be thrown, but only bytes through
     * the end of the array will be processed.</p>
     *
     * @param  bytes  the input data bytes
     * @param  offset the start offset of the data
     * @param  length the length of the data
     * @throws NullPointerException if input is <code>null</code>
     * @throws ArrayIndexOutOfBoundsException if <code>offset</code> or
     *  <code>length</code> is negative, or their sum exceeds the
     *  length of the array
     */
    public void setInput(final byte[] bytes,
                         final int offset,
                         final int length) {
        if (bytes == null) {
            throw new NullPointerException("Input bytes cannot be null");
        }
        if (offset < 0
                || length < 0
                || offset + length > bytes.length) {
	        throw new ArrayIndexOutOfBoundsException("Invalid offset/length");
	    }

        if (length > 0) {
            inputBytes = bytes;
            inputPosition = offset;
            if (offset + length > bytes.length) {
                inputMax = bytes.length;
                totalIn += bytes.length - offset;
            } else {
                inputMax = offset + length;
                totalIn += length;
            }
            // Will throw an exception in inflate if inputMax - inputPosition
            // is not divisible by 3
        } else {
            clearInput();
        }
    }

    /**
     * <p>Fills specified buffer with decompressed data. Returns actual number
     * of bytes of decompressed data. A return value of 0 indicates that
     * {@link #needsInput()} should be called in order to determine if more
     * input data is required.</p>
     *
     * <p>Note that if <code>outputOffset + outputLength</code> exceeds the
     * length of the output array, no exception will be thrown, but only
     * bytes through the end of the array will be written with decompressed
     * data.</p>
     *
     * <p>Also note that the input array must have a length that is a
     * multiple of 3.</p>
     *
     * @param  outputBytes the buffer for the decompressed data
     * @return the actual number of bytes of decompressed data
     * @throws NullPointerException if output is <code>null</code>
     * @throws DataFormatException if the array length is
     *  not a multiple of 3, or if any triplet of bytes contains a match
     *  offset and length whose sum exceeds the current output position
     *  (that is, it indicates a match that extends beyond the end of the
     *  current window)
     */
    public int inflate(final byte[] outputBytes) throws DataFormatException {
        if (outputBytes == null) {
            throw new NullPointerException("Output bytes cannot be null");
        }
        return inflate(outputBytes, 0, outputBytes.length);
    }

    /**
     * <p>Fills specified buffer with decompressed data. Returns actual number
     * of bytes of decompressed data. A return value of 0 indicates that
     * {@link #needsInput()} should be called in order to determine if more
     * input data is required.</p>
     *
     * <p>Note that if <code>outputOffset + outputLength</code> exceeds the
     * length of the output array, no exception will be thrown, but only
     * bytes through the end of the array will be written with decompressed
     * data.</p>
     *
     * <p>Also note that the number of bytes must be a multiple of 3.</p>
     *
     * @param  outputBytes the buffer for the decompressed data
     * @param  outputOffset the start offset of the data
     * @param  outputLength the maximum number of bytes of decompressed data
     * @return the actual number of bytes of decompressed data
     * @throws NullPointerException if output is <code>null</code>
     * @throws ArrayIndexOutOfBoundsException if <code>outputOffset</code> or
     *  <code>outputLength</code> is negative, or their sum exceeds the
     *  length of the array
     * @throws DataFormatException if <code>outputLength</code> is
     *  not a multiple of 3, or if any triplet of bytes contains a match
     *  offset and length whose sum exceeds the current output position
     *  (that is, it indicates a match that extends beyond the end of the
     *  current window)
     */
    public int inflate(final byte[] outputBytes,
                       final int outputOffset,
                       final int outputLength) throws DataFormatException {

        if (outputBytes == null) {
            throw new NullPointerException("Output bytes cannot be null");
        }
        if (outputOffset < 0
                || outputLength < 0
                || outputOffset + outputLength > outputBytes.length) {
	        throw new ArrayIndexOutOfBoundsException("Invalid offset/length");
	    }

        if (needsInput()) {
            return 0;
        }

        if ((inputMax - inputPosition) % 3 != 0) {
            throw new DataFormatException("Input length is not divisible by 3");
        }

        int outputPosition = outputOffset;
        final int outputMax;
        if (outputOffset + outputLength > outputBytes.length) {
            output.setNextBuffer(outputBytes,
                                 outputOffset,
                                 outputBytes.length - outputOffset);
            outputMax = outputBytes.length;
        } else {
            output.setNextBuffer(outputBytes, outputOffset, outputLength);
            outputMax = outputOffset + outputLength;
        }

        int bytesDecoded = 0;
        while (inputPosition < inputMax && outputPosition < outputMax) {

            // "& 0xFF" because byte should be treated as unsigned
            final int matchLength = inputBytes[inputPosition + 1] & 0xFF;
            if (matchLength > 0) {
                // Match in window; copy match to output
                if (outputPosition + matchLength + 1 > outputMax) {
                    // Not enough room to copy decoded bytes, so stop
                    break;
                } else {

                    final int matchOffset = inputBytes[inputPosition] & 0xFF;
                    // Note that matchOffset is relative to current output
                    // position, not from start of lookback window

                    // Copy match to output
                    try {
                        output.copyFromLookbackToBuffer(matchOffset,
                                                        outputPosition,
                                                        matchLength);
                    } catch (ArrayIndexOutOfBoundsException aioobe) {
                        throw new DataFormatException("Invalid match offset/length");
                    }
                    outputPosition += matchLength;

                    // Copy last byte to output
                    outputBytes[outputPosition] = inputBytes[inputPosition + 2];
                    outputPosition++;

                    bytesDecoded += matchLength + 1;
                }

            } else {
                // No match in window
                outputBytes[outputPosition] = inputBytes[inputPosition + 2];
                outputPosition++;
                bytesDecoded++;
            }

            inputPosition += 3;
        }

        if (inputPosition >= inputMax) {
            clearInput();
        }

        totalOut += bytesDecoded;

        // Remember that not all of the output array was actuall written
        // with output; this ensures that the unused parts are not saved
        // as part of the output
        output.saveLookback(bytesDecoded);

        return bytesDecoded;
    }

    /**
     * <p>Returns <code>true</code> iff there are no input bytes left to
     * process.</p>
     *
     * @return <code>true</code> iff there are no input bytes left to process
     */
    public boolean needsInput() {
        return inputBytes == null;
    }

    /**
     * <p>Returns <code>true</code> iff there are no input bytes left to
     * process.</p>
     *
     * @return <code>true</code> iff there are no input bytes left to process
     */
    public boolean finished() {
        return inputBytes == null;
    }

    /**
     * <p>Ends decoding process and discards any unprocessed input data.</p>
     */
    public void end() {
        clearInput();
        output.clear();
    }

    /**
     * <p>Resets this decoder to its initial state. This also means that any
     * unprocessed input data is discarded.</p>
     */
    public void reset() {
        clearInput();
        output.clear();
        totalIn = 0;
        totalOut = 0;
    }

    /**
     * <p>Returns the number of bytes left in the input.</p>
     *
     * @return number of bytes left in the input
     */
    public int getRemaining() {
        return inputBytes == null ? 0 : inputMax - inputPosition;
    }

    /**
     * <p>Returns the total number of bytes input so far.</p>
     *
     * @return the total number of bytes input so far
     */
    public int getTotalIn() {
        return totalIn;
    }

    /**
     * <p>Returns the total number of bytes output so far.</p>
     *
     * @return the total number of bytes output so far
     */
    public int getTotalOut() {
        return totalOut;
    }

    private void clearInput() {
        inputBytes = null;
        inputPosition = 0;
        inputMax = 0;
    }
}
package com.topcoder.util.compression;

import java.util.zip.Deflater;

/**
 * <p>This subclass of <code>Deflater</code> overrides its methods to implement
 *  the Lempel-Ziv (LZ77) compression algorithm.</p>
 *
 * <p>Note that this class is not thread-safe.</p>
 *
 * <p>Copyright &copy; 2003, TopCoder Inc. All rights reserved.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 * @see     <a href="http://www.free2code.net/tutorials/other/20/LZ77.php">
 *          LZ77 tutorial</a>
 * @see     <a href="http://www.stanford.edu/class/ee398a/resources/ziv:77-SDC.pdf">
 *          A Universal Algorithm for Sequential Data Compression</a>
 */
public class LZ77Encoder extends Deflater {

    /** Maximum size of lookback window used during encoding. */
    private static final int WINDOW_SIZE = LZ77Codec.WINDOW_SIZE;

    private byte[] inputBytes;
    private int inputOffset;
    private int inputPosition;
    private int inputMax;
    private int totalIn;
    private int totalOut;

    /**
     * <p>Sets input data for compression. This should be called whenever
     * {@link #needsInput()} returns <code>true</code> indicating that more
     * input data is required.</p>
     *
     * @param  inputBytes the input data bytes
     * @throws NullPointerException if input is <code>null</code>
     */
    public void setInput(final byte[] inputBytes) {
        if (inputBytes == null) {
            throw new NullPointerException("Input bytes cannot be null");
        }
        setInput(inputBytes, 0, inputBytes.length);
    }

    /**
     * <p>Sets input data for compression. This should be called whenever
     * {@link #needsInput()} returns <code>true</code> indicating that more
     * input data is required.</p>
     *
     * <p>Note that if <code>inputOffset + length</code> exceeds the length of
     * the input array, no exception will be thrown, but only bytes through
     * the end of the array will be processed.</p>
     *
     * @param  bytes  the input data bytes
     * @param  offset the start offset of the data
     * @param  length the length of the data
     * @throws NullPointerException if input is <code>null</code>
     * @throws ArrayIndexOutOfBoundsException if <code>inputOffset</code> or
     *  <code>length</code> is negative, or their sum exceeds the
     *  length of the array
     */
    public void setInput(final byte[] bytes,
                         final int offset,
                         final int length) {
        if (bytes == null) {
            throw new NullPointerException("Input bytes cannot be null");
        }
        if (offset < 0
                || length < 0
                || offset + length > bytes.length) {
            throw new ArrayIndexOutOfBoundsException("Invalid offset/length");
        }

        if (length > 0) {
            inputBytes = bytes;
            inputOffset = offset;
            inputPosition = offset;
            if (offset + length > bytes.length) {
                inputMax = bytes.length;
                totalIn += bytes.length - offset;
            } else {
                inputMax = offset + length;
                totalIn += length;
            }
        } else {
            clearInput();
        }
    }

    /**
     * <p>Fills specified buffer with compressed data. Returns actual number
     * of bytes of compressed data. A return value of 0 indicates that
     * {@link #needsInput()} should be called in order to determine if more
     * input data is required.</p>
     *
     * @param  outputBytes the buffer for the compressed data
     * @return the actual number of bytes of compressed data
     * @throws NullPointerException if output is <code>null</code>
     */
    public int deflate(final byte[] outputBytes) {
        if (outputBytes == null) {
            throw new NullPointerException("Output bytes cannot be null");
        }
        return deflate(outputBytes, 0, outputBytes.length);
    }

    /**
     * <p>Fills specified buffer with compressed data. Returns actual number
     * of bytes of compressed data. A return value of 0 indicates that
     * {@link #needsInput()} should be called in order to determine if more
     * input data is required.</p>
     *
     * <p>Note that if <code>outputOffset + outputLength</code> exceeds the
     * length of the output array, no exception will be thrown, but only
     * bytes through the end of the array will be written with compressed
     * data.</p>
     *
     * @param  outputBytes the buffer for the compressed data
     * @param  outputOffset the start offset of the data
     * @param  outputLength the maximum number of bytes of compressed data
     * @return the actual number of bytes of compressed data
     * @throws NullPointerException if output is <code>null</code>
     * @throws ArrayIndexOutOfBoundsException if <code>outputOffset</code> or
     *  <code>outputLength</code> is negative, or their sum exceeds the
     *  length of the array
     */
    public int deflate(final byte[] outputBytes,
                       final int outputOffset,
                       final int outputLength) {

        if (outputBytes == null) {
            throw new NullPointerException("Output bytes cannot be null");
        }
        if (outputOffset < 0
                || outputLength < 0
                || outputOffset + outputLength > outputBytes.length) {
            throw new ArrayIndexOutOfBoundsException("Invalid offset/length");
        }

        if (needsInput()) {
            return 0;
        }

        int outputPosition = outputOffset;
        // "- 2" is to make sure that there is always room to write 3
        // bytes in the output, since every step of the encoding produces
        // 3 bytes
        final int outputMax =
                (outputOffset + outputLength > outputBytes.length
                ? outputBytes.length
                : outputOffset + outputLength) - 2;

        // "inputMax - 1" since we always want to leave one byte at
        // the end to output in the last triplet of bytes
        final int kMax = inputMax - 1;

        // Use local reference for better performance
        final byte[] inputBytes = this.inputBytes;

        int bytesEncoded = 0;
        while (outputPosition < outputMax && inputPosition < inputMax) {

            // Why "+ 1"? When there is a full WINDOW_SIZE byte behind
            // the input position, a match could start at the start of
            // the window, meaning matchOffset below would be
            // WINDOW_SIZE. But if WINDOW_SIZE = 256, then this results
            // in the byte value 0 being encoded. So, we prevent this by
            // not allowing a match starting at the very start of the window
            final int windowStart =
                    inputPosition - inputOffset >= WINDOW_SIZE
                    ? inputPosition - WINDOW_SIZE + 1
                    : inputOffset;

            int maximalMatchStart = 0;
            int maximalMatchLength = 0;

            final int jMax = inputPosition;

            // Look for longest match from start of window
            for (int i = windowStart, iMax = inputPosition; i < iMax; i++) {

                // shortcut for the common case:
                if (inputPosition < kMax
                        && inputBytes[i] == inputBytes[inputPosition]) {

                    // Find length of match from index i
                    int j = i + 1;
                    for (int k = inputPosition + 1;
                         j < jMax && k < kMax && inputBytes[j] == inputBytes[k];
                         j++, k++); // note: no loop body

                    // If there is any match,
                    if (j > i) {
                        // and it is the longest so far, record it
                        final int matchLength = j - i;
                        // ">=" so as to get *last* best match --
                        // a little better for the decoder
                        if (matchLength >= maximalMatchLength) {
                            maximalMatchLength = matchLength;
                            iMax = inputPosition - maximalMatchLength;
                            maximalMatchStart = i;
                        }
                    }
                }
            }

            if (maximalMatchLength > 0) {
                // Found a match.
                // Output offset of start of match, as a number of bytes
                // *back* from the current input position, not *forwards*
                // from the window start
                outputBytes[outputPosition] =
                        (byte) (inputPosition - maximalMatchStart);
                outputBytes[outputPosition + 1] = (byte) maximalMatchLength;
                outputBytes[outputPosition + 2] =
                        inputBytes[inputPosition + maximalMatchLength];
                inputPosition += maximalMatchLength + 1;
            } else {
                // No match
                outputBytes[outputPosition] = 0;
                outputBytes[outputPosition + 1] = 0;
                outputBytes[outputPosition + 2] = inputBytes[inputPosition];
                inputPosition++;
            }

            outputPosition += 3;
            bytesEncoded += 3;
        }

        totalOut += bytesEncoded;

        if (inputPosition >= inputMax) {
            clearInput();
        }

        return bytesEncoded;
    }

    /**
     * <p>Returns <code>true</code> iff there are no input bytes left to
     * process.</p>
     *
     * @return <code>true</code> iff there are no input bytes left to process
     */
    public boolean needsInput() {
        return inputBytes == null;
    }

    /**
     * <p>Returns <code>true</code> iff there are no input bytes left to
     * process.</p>
     *
     * @return <code>true</code> iff there are no input bytes left to process
     */
    public boolean finished() {
        return inputBytes == null;
    }

    /**
     * <p>Ends encoding process and discards any unprocessed input data.</p>
     */
    public void end() {
        clearInput();
    }

    /**
     * <p>Resets this encoder to its initial state. This also means that any
     * unprocessed input data is discarded.</p>
     */
    public void reset() {
        clearInput();
        totalIn = 0;
        totalOut = 0;
    }

    /**
     * <p>Lets the encoder know that no more input data will be provided.
     * Currently this does nothing.</p>
     */
    public void finish() {
        // do nothing
    }

    /**
     * <p>Returns the total number of bytes input so far.</p>
     *
     * @return the total number of bytes input so far
     */
    public int getTotalIn() {
        return totalIn;
    }

    /**
     * <p>Returns the total number of bytes output so far.</p>
     *
     * @return the total number of bytes output so far
     */
    public int getTotalOut() {
        return totalOut;
    }

    private void clearInput() {
        inputBytes = null;
        inputOffset = 0;
        inputPosition = 0;
        inputMax = 0;
    }
}
package com.topcoder.util.compression;

import java.io.OutputStream;

/**
 * <p>A simple utility <code>OutputStream</code> implementation that translates
 * bytes to characters according to the platform's default encoding, and
 * appends them to a <code>StringBuffer</code>.</p>
 *
 * <p>Copyright &copy; 2003, TopCoder Inc. All rights reserved.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 */
final class StringBufferOutputStream extends OutputStream {

    private final StringBuffer buffer;

    /**
     * <p>Creates a <code>StringBufferOutputStream</code> that appends to
     * the given <code>StringBuffer</code>.</p>
     *
     * @param buffer <code>StringBuffer</code> to append to
     */
    StringBufferOutputStream(final StringBuffer buffer) {
        this.buffer = buffer;
    }

    /**
     * <p>Converts an array of bytes to characters according to the platform's
     * default character encoding and appends them to the
     * <code>StringBuffer</code>.</p>
     *
     * @param b byte array
     */
    public void write(final byte[] b) {
        write(b, 0, b.length);
    }

    /**
     * <p>Converts an array of bytes to characters according to the platform's
     * default character encoding and appends them to the
     * <code>StringBuffer</code>.</p>
     *
     * @param b      byte array
     * @param offset offset into array to start reading from
     * @param length number of bytes to read
     */
    public void write(final byte[] b, final int offset, final int length) {
        buffer.append(new String(b, offset, length));
    }

    /**
     * <p>Construes a single unsigned byte as a character and appends it to
     * the <code>StringBuffer</code>.</p>
     *
     * @param b character value to append
     */
    public void write(final int b) {
        buffer.append((char) (b & 0xFF));
    }

    /**
     * <p>Does nothing. Note that this does not throw
     * <code>IOException</code>.</p>
     */
    public void flush() {
    }

    /**
     * <p>Does nothing. Note that this does not throw
     * <code>IOException</code>.</p>
     */
    public void close() {
    }
}
package com.topcoder.util.compression;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

import junit.framework.TestCase;

/**
 * <p>Tests functionality of a <code>Codec</code> implementation. This
 * class tests functionality that should be common to all implementations;
 * subclasses can perform more specific tests.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 */
public abstract class AbstractCodecTestCase extends TestCase {

    private static final File TEST_FILES_DIR = new File("test_files");
    private static final File[] TEST_FILES = new File[] {
        new File(TEST_FILES_DIR, "midsummernightsdream.txt"),
        new File(TEST_FILES_DIR, "sunset.jpg"),
        new File(TEST_FILES_DIR, "ed")
    };

    /**
     * @return name of <code>Codec</code> implementation class
     */
    abstract String getCodecClassName();

    public void testCompressDecompressFile() throws Exception {
        for (int i = 0; i < TEST_FILES.length; i++) {
            doTestCompressDecompressFile(TEST_FILES[i]);
        }
    }

    private void doTestCompressDecompressFile(final File input)
        throws Exception
    {
        final File compressed = File.createTempFile("compress", null);
        compressed.deleteOnExit();
        final File decompressed = File.createTempFile("decompress", null);
        decompressed.deleteOnExit();

        final CompressionUtility compressor =
                new CompressionUtility(getCodecClassName(), compressed);

        compressor.compress(input);
        compressor.close();

        final CompressionUtility decompressor =
                new CompressionUtility(getCodecClassName(), decompressed);

        decompressor.decompress(compressed);
        decompressor.close();

        assertEquals(input.length(), decompressed.length());
        assertTrue(CompressionTestUtils.filesMatch(input, decompressed));

        compressed.delete();
        decompressed.delete();
    }

    public void testCompressDecompressInputStream() throws Exception {
        for (int i = 0; i < TEST_FILES.length; i++) {
            doTestCompressDecompressInputStream(TEST_FILES[i]);
        }
    }

    private void doTestCompressDecompressInputStream(final File input)
        throws Exception
    {
        final File compressed = File.createTempFile("compress", null);
        compressed.deleteOnExit();
        final File decompressed = File.createTempFile("decompress", null);
        decompressed.deleteOnExit();

        final CompressionUtility compressor =
                new CompressionUtility(getCodecClassName(), new FileOutputStream(compressed));

        compressor.compress(new FileInputStream(input));
        compressor.close();

        final CompressionUtility decompressor =
                new CompressionUtility(getCodecClassName(), new FileOutputStream(decompressed));

        decompressor.decompress(new FileInputStream(compressed));
        decompressor.close();

        assertEquals(input.length(), decompressed.length());
        assertTrue(CompressionTestUtils.filesMatch(input, decompressed));

        compressed.delete();
        decompressed.delete();
    }

    public void testCompressDecompressStringBuffer() throws Exception {
        for (int i = 0; i < TEST_FILES.length; i++) {
            doTestCompressDecompressStringBuffer(TEST_FILES[i]);
        }
    }

    private void doTestCompressDecompressStringBuffer(final File input)
        throws Exception
    {
        final File compressed = File.createTempFile("compress", null);
        compressed.deleteOnExit();
        final File decompressed = File.createTempFile("decompress", null);
        decompressed.deleteOnExit();

        final CompressionUtility compressor =
                new CompressionUtility(getCodecClassName(), new FileOutputStream(compressed));

        String contents = CompressionTestUtils.readFileAsString(input);
        compressor.compress(new StringBuffer(contents));
        compressor.close();

        final CompressionUtility decompressor =
                new CompressionUtility(getCodecClassName(), new FileOutputStream(decompressed));

        contents = CompressionTestUtils.readFileAsString(compressed);
        decompressor.decompress(new StringBuffer(contents));
        decompressor.close();

        assertEquals(input.length(), decompressed.length());
        assertTrue(CompressionTestUtils.filesMatch(input, decompressed));

        compressed.delete();
        decompressed.delete();
    }


    public void testSetInputIllegalArgs() throws Exception {
        final Codec codec = CompressionUtility.createCodec(getCodecClassName());
        assertNotNull(codec);

        final Deflater deflater = codec.createDeflater();
        assertNotNull(deflater);

        final Inflater inflater = codec.createInflater();
        assertNotNull(inflater);

        try {
            deflater.setInput(null);
            fail("Should have thrown NullPointerException");
        } catch (NullPointerException npe) {
            // good
        }
        try {
            deflater.setInput(null, 0, 0);
            fail("Should have thrown NullPointerException");
        } catch (NullPointerException npe) {
            // good
        }
        try {
            deflater.setInput(new byte[0], -1, 0);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }
        try {
            deflater.setInput(new byte[0], 0, -1);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }
        try {
            deflater.setInput(new byte[1], 0, 2);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }

        try {
            inflater.setInput(null);
            fail("Should have thrown NullPointerException");
        } catch (NullPointerException npe) {
            // good
        }
        try {
            inflater.setInput(null, 0, 0);
            fail("Should have thrown NullPointerException");
        } catch (NullPointerException npe) {
            // good
        }
        try {
            inflater.setInput(new byte[0], -1, 0);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }
        try {
            inflater.setInput(new byte[0], 0, -1);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }
        try {
            inflater.setInput(new byte[1], 0, 2);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }
    }

    public void testDeflateInflateIllegalArgs() throws Exception {
        final Codec codec = CompressionUtility.createCodec(getCodecClassName());
        assertNotNull(codec);

        final Deflater deflater = codec.createDeflater();
        assertNotNull(deflater);

        final Inflater inflater = codec.createInflater();
        assertNotNull(inflater);

        try {
            deflater.deflate(null);
            fail("Should have thrown NullPointerException");
        } catch (NullPointerException npe) {
            // good
        }
        try {
            deflater.deflate(null, 0, 0);
            fail("Should have thrown NullPointerException");
        } catch (NullPointerException npe) {
            // good
        }
        try {
            deflater.deflate(new byte[0], -1, 0);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }
        try {
            deflater.deflate(new byte[0], 0, -1);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }
        try {
            deflater.deflate(new byte[1], 0, 2);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }

        try {
            inflater.inflate(null);
            fail("Should have thrown NullPointerException");
        } catch (NullPointerException npe) {
            // good
        }
        try {
            inflater.inflate(null, 0, 0);
            fail("Should have thrown NullPointerException");
        } catch (NullPointerException npe) {
            // good
        }
        try {
            inflater.inflate(new byte[0], -1, 0);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }
        try {
            inflater.inflate(new byte[0], 0, -1);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }
        try {
            inflater.inflate(new byte[1], 0, 2);
            fail("Should have thrown ArrayIndexOutOfBoundsException");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            // good
        }
    }

}
package com.topcoder.util.compression;

import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import com.topcoder.util.compression.functionaltests.FunctionalTests;
//import com.topcoder.util.compression.accuracytests.AccuracyTests;
//import com.topcoder.util.compression.failuretests.FailureTests;
//import com.topcoder.util.compression.stresstests.StressTests;

/**
 * <p>This test case aggregates all test cases for this package.</p>
 *
 * @author TopCoder Software
 * @version 1.0
 */
public class AllTests extends TestCase {

    public static Test suite() {
        final TestSuite suite = new TestSuite();
        
        //unit tests
        suite.addTest(UnitTests.suite());
        
        //functional tests
        suite.addTest(FunctionalTests.suite());
        
        //accuracy tests
//        suite.addTest(AccuracyTests.suite());
        
        //failure tests
 //       suite.addTest(FailureTests.suite());
        
        //stress tests
//        suite.addTest(StressTests.suite());
        
        return suite;
    }

}
package com.topcoder.util.compression;

import java.io.File;
import java.io.IOException;
import java.io.FileReader;

/**
 * <p>Utility methods used in test cases.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 */
final class CompressionTestUtils {

    private CompressionTestUtils() {
    }

    /**
     * <p>Returns <code>true</code> iff the given parts of the two arrays
     * are equal.</p>
     *
     * @param  b1     first byte array
     * @param  offset1 first index of first byte array to compare
     * @param  b2     second byte array
     * @param  offset2 first index of second byte array to compare
     * @param  length  number of byte to compare
     * @return <code>true</code> iff the given parts of the two arrays
     *  are equal
     */
    static boolean arraysEqual(final byte[] b1,
                               final int offset1,
                               final byte[] b2,
                               final int offset2,
                               final int length) {
        for (int i = 0; i < length; i++) {
            if (b1[offset1 + i] != b2[offset2 + i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * <p>Returns a useful String representation of a byte array.</p>
     *
     * @param  b      byte array
     * @param  offset first index to output
     * @param  length number of bytes to output
     * @return String representation of part of the byte array
     */
    static String arrayToString(final byte[] b,
                                final int offset,
                                final int length) {
        final StringBuffer result = new StringBuffer(5 * length);
        result.append('{');
        boolean first = true;
        for (int i = 0; i < length; i++) {
            if (first) {
                first = false;
            } else {
                result.append(',');
            }
            result.append(b[offset + i]);
        }
        result.append('}');
        return result.toString();
    }

    /**
     * <p>Reads a File's contents as a String.</p>
     *
     * @param  f File to read
     * @return File's contents as String
     * @throws IOException
     */
    static String readFileAsString(final File f) throws IOException {
        final FileReader fr = new FileReader(f);
        final StringBuffer result = new StringBuffer();
        final char[] buffer = new char[1024];
        int charsRead;
        try {
            while ((charsRead = fr.read(buffer)) > 0) {
                result.append(buffer, 0, charsRead);
            }
        } finally {
            fr.close();
        }
        return result.toString();
    }

    /**
     * @param  f1 first File to compare
     * @param  f2 second File to compare
     * @return <code>true</code> iff files are identical
     * @throws IOException
     */
    static boolean filesMatch(final File f1, final File f2) throws IOException {
        return readFileAsString(f1).equals(readFileAsString(f2));
    }
}
package com.topcoder.util.compression;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.OutputStream;

import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

/**
 * <p>Tests basic functionality of the <code>CompressionUtility</code>
 * class. It does not test compression / decompression functionality;
 * that is tested in {@link AbstractCodecTestCase}.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 */
public class CompressionUtilityTestCase extends TestCase {

    private static final String DEFAULT_CODEC_CLASS_NAME =
            DefaultCodec.class.getName();

    public void testConstructorIllegalArgs() throws Exception {
        final OutputStream dummyStream = new ByteArrayOutputStream();
        final File dummyFile = new File(".");
        final File realFile = new File(new File("test_files"), "somefile");
        final StringBuffer dummyBuffer = new StringBuffer();

        try {
            new CompressionUtility(DEFAULT_CODEC_CLASS_NAME,
                                   (OutputStream) null);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException iae) {
            // good
        }
        try {
            new CompressionUtility(null, dummyStream);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException iae) {
            // good
        }
        try {
            new CompressionUtility(DEFAULT_CODEC_CLASS_NAME,
                                   (File) null);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException iae) {
            // good
        }
        try {
            new CompressionUtility(null, dummyFile);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException iae) {
            // good
        }
        try {
            new CompressionUtility(DEFAULT_CODEC_CLASS_NAME,
                                   (StringBuffer) null);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException iae) {
            // good
        }
        try {
            new CompressionUtility(null, dummyBuffer);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException iae) {
            // good
        }

        try {
            new CompressionUtility(DEFAULT_CODEC_CLASS_NAME, dummyFile);
            fail("Should have thrown FileNotFoundException");
        } catch (FileNotFoundException fnfe) {
            // good
        }

        try {
            new CompressionUtility("nosuchclass", dummyStream);
            fail("Should have thrown ClassNotFoundException");
        } catch (ClassNotFoundException cnfe) {
            // good
        }
        try {
            new CompressionUtility("nosuchclass", realFile);
            fail("Should have thrown ClassNotFoundException");
        } catch (ClassNotFoundException cnfe) {
            // good
        }
        try {
            new CompressionUtility("nosuchclass", dummyBuffer);
            fail("Should have thrown ClassNotFoundException");
        } catch (ClassNotFoundException cnfe) {
            // good
        }
    }

    public void testCreateCodecIllegalArgs() throws Exception {
        try {
            CompressionUtility.createCodec(null);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException iae) {
            // good
        }
        try {
            CompressionUtility.createCodec("nosuchclass");
            fail("Should have thrown ClassNotFoundException");
        } catch (ClassNotFoundException cnfe) {
            // good
        }
        try {
            CompressionUtility.createCodec("java.io.Serializable");
            fail("Should have thrown InstantiationException");
        } catch (InstantiationException ie) {
            // good
        }
        try {
            CompressionUtility.createCodec("java.lang.Object");
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException ie) {
            // good
        }
    }

    public void testCompressDecompressIllegalArgs() throws Exception {
        final File dummyFile = new File(".");
        final File realFile = new File(new File("test_files"), "somefile");
        final CompressionUtility cu =
                new CompressionUtility(DEFAULT_CODEC_CLASS_NAME, realFile);

        try {
            cu.compress((InputStream) null);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException ie) {
            // good
        }
        try {
            cu.compress((File) null);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException ie) {
            // good
        }
        try {
            cu.compress((StringBuffer) null);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException ie) {
            // good
        }

        try {
            cu.decompress((InputStream) null);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException ie) {
            // good
        }
        try {
            cu.decompress((File) null);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException ie) {
            // good
        }
        try {
            cu.decompress((StringBuffer) null);
            fail("Should have thrown IllegalArgumentException");
        } catch (IllegalArgumentException ie) {
            // good
        }

        try {
            cu.compress(dummyFile);
            fail("Should have thrown FileNotFoundException");
        } catch (FileNotFoundException fnfe) {
            // good
        }

        try {
            cu.decompress(dummyFile);
            fail("Should have thrown FileNotFoundException");
        } catch (FileNotFoundException fnfe) {
            // good
        }
    }

    public void testCreateCodec() throws Exception {
        Codec c = CompressionUtility.createCodec(DEFAULT_CODEC_CLASS_NAME);
        assertNotNull(c);
        assertTrue(c instanceof DefaultCodec);

        c = CompressionUtility.createCodec("com.topcoder.util.compression.LZ77Codec");
        assertNotNull(c);
        assertTrue(c instanceof LZ77Codec);
    }


    public static Test suite() {
        return new TestSuite(CompressionUtilityTestCase.class);
    }
}
package com.topcoder.util.compression;

import junit.framework.Test;
import junit.framework.TestSuite;

/**
 * <p>Tests functionality of the <code>DefaultCodec</code> implementation.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 */
public class DefaultCodecTestCase extends AbstractCodecTestCase {

    /**
     * @return name of <code>Codec</code> implementation class
     */
    String getCodecClassName() {
        return "com.topcoder.util.compression.DefaultCodec";
    }

    public static Test suite() {
        return new TestSuite(DefaultCodecTestCase.class);
    }
}
package com.topcoder.util.compression;

import java.util.Arrays;
import java.util.zip.DataFormatException;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

import junit.framework.Test;
import junit.framework.TestSuite;

/**
 * <p>Tests functionality of the <code>LZ77Codec</code> implementation.</p>
 *
 * @author  TCSDEVELOPER
 * @version 1.0
 */
public class LZ77CodecTestCase extends AbstractCodecTestCase {

    /**
     * @return name of <code>Codec</code> implementation class
     */
    String getCodecClassName() {
        return "com.topcoder.util.compression.LZ77Codec";
    }

    public void testDeflaterInflater() throws Exception {
        final Codec codec = new LZ77Codec();

        doTestDeflaterInflater(
                codec,
                new byte[]{0, 0, 1, 1, 0, 1, 0, 1},
                new byte[]{0, 0, 0, 1, 1, 1, 1, 1, 0, 2, 2, 1});

        doTestDeflaterInflater(
                codec,
                new byte[]{100},
                new byte[]{0, 0, 100});

        doTestDeflaterInflater(
                codec,
                new byte[]{100, 100},
                new byte[]{0, 0, 100, 0, 0, 100});

        doTestDeflaterInflater(
                codec,
                new byte[]{100, 100, 100},
                new byte[]{0, 0, 100, 1, 1, 100});

        byte[] zeroes = new byte[256];
        Arrays.fill(zeroes, (byte) 0);
        doTestDeflaterInflater(
                codec,
                zeroes,
                new byte[]{0, 0, 0, 1, 1, 0, 3, 3, 0, 7, 7, 0, 15, 15, 0,
                           31, 31, 0, 63, 63, 0, 127, 127, 0, 0, 0, 0});
        zeroes = new byte[257];
        Arrays.fill(zeroes, (byte) 0);
        doTestDeflaterInflater(
                codec,
                zeroes,
                new byte[]{0, 0, 0, 1, 1, 0, 3, 3, 0, 7, 7, 0, 15, 15, 0,
                           31, 31, 0, 63, 63, 0, 127, 127, 0, 2, 1, 0});

    }

    private void doTestDeflaterInflater(final Codec c,
                                        final byte[] uncompressed,
                                        final byte[] compressed)
            throws Exception
    {
        final Deflater deflater = c.createDeflater();
        final Inflater inflater = c.createInflater();

        for (int i = 0; i < 2; i++) {

            // Test deflater

            assertTrue(deflater.needsInput());

            deflater.setInput(uncompressed);

            final byte[] temp = new byte[3 * uncompressed.length];
            final int bytesEncoded = deflater.deflate(temp);
            assertEquals(uncompressed.length, deflater.getTotalIn());
            assertEquals(bytesEncoded, deflater.getTotalOut());

            deflater.finish();
            deflater.end();

            // Should have consumed all input
            assertTrue(deflater.needsInput());
            assertTrue(deflater.finished());

            if (compressed.length != bytesEncoded
                    || !CompressionTestUtils.arraysEqual(compressed,
                                                         0,
                                                         temp,
                                                         0,
                                                         compressed.length)) {
                fail("Arrays unequal; expected " +
                     CompressionTestUtils.arrayToString(compressed,
                                                        0,
                                                        compressed.length) +
                     " but was " +
                     CompressionTestUtils.arrayToString(temp, 0, bytesEncoded));
            }

            // Test inflater

            assertTrue(inflater.needsInput());

            inflater.setInput(compressed);
            assertEquals(compressed.length, inflater.getRemaining());

            final byte[] temp2 = new byte[10 * uncompressed.length];
            final int bytesDecoded = inflater.inflate(temp2);
            assertEquals(compressed.length, inflater.getTotalIn());
            assertEquals(bytesDecoded, inflater.getTotalOut());

            assertEquals(0, inflater.getRemaining());

            inflater.end();

            // Should have consumed all input
            assertTrue(inflater.needsInput());
            assertTrue(inflater.finished());

            if (uncompressed.length != bytesDecoded
                    || !CompressionTestUtils.arraysEqual(uncompressed,
                                                         0,
                                                         temp2,
                                                         0,
                                                         uncompressed.length))
            {
                fail("Arrays unequal; expected " +
                     CompressionTestUtils.arrayToString(uncompressed,
                                                        0,
                                                        uncompressed.length) +
                     " but was " +
                     CompressionTestUtils.arrayToString(temp2,
                                                        0,
                                                        bytesDecoded));
            }

            // make sure it works again after a reset
            deflater.reset();
            inflater.reset();
            assertEquals(0, deflater.getTotalIn());
            assertEquals(0, inflater.getTotalIn());
            assertEquals(0, deflater.getTotalOut());
            assertEquals(0, inflater.getTotalOut());
        }
    }

    public void testIllegalArgs() throws Exception {
        try {
            final Inflater i = new LZ77Decoder();
            i.setInput(new byte[5]);
            i.inflate(new byte[128]);
            fail("Should have thrown DataFormatException");
        } catch (DataFormatException dfe) {
            // good
        }
    }

    public static Test suite() {
        return new TestSuite(LZ77CodecTestCase.class);
    }
}
package com.topcoder.util.compression;

import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

/**
 * <p>This test case aggregates all unit test cases.</p>
 *
 * @author TopCoder Software
 * @version 1.0
 */
public class UnitTests extends TestCase {

    public static Test suite() {
        final TestSuite suite = new TestSuite();
        suite.addTest(CompressionUtilityTestCase.suite());
        suite.addTest(LZ77CodecTestCase.suite());
        suite.addTest(DefaultCodecTestCase.suite());
        return suite;
    }

}
package com.topcoder.util.compression.functionaltests;

import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

import java.io.*;
import com.topcoder.util.compression.*;

/**
 * <p>This test case contains tests for basic compression use cases.</p>
 *
 * @author TopCoder Software
 * @version 1.0
 */
public class CompressionTests extends TestCase {

    public static void testFileCompressWithLZ77() throws Exception {
	doTestFileCompress( "com.topcoder.util.compression.LZ77Codec" );
    }

    public static void testFileCompressWithDefault() throws Exception {
	doTestFileCompress( "com.topcoder.util.compression.DefaultCodec" );
    }

    public static void testStringBufferCompressWithLZ77() throws Exception {
	doTestStringBufferCompress( "com.topcoder.util.compression.LZ77Codec" );
    }

    public static void testStringBufferCompressWithDefault() throws Exception {
	doTestStringBufferCompress( "com.topcoder.util.compression.DefaultCodec" );
    }

    public static void testStreamCompressWithLZ77() throws Exception {
	doTestStreamCompress( "com.topcoder.util.compression.LZ77Codec" );
    }

    public static void testStreamCompressWithDefault() throws Exception {
	doTestStreamCompress( "com.topcoder.util.compression.DefaultCodec" );
    }


    public static void doTestFileCompress( String codecName ) throws Exception {
	// delete old files
	File oldCompressedFile = new File( "compressed.txt" );
	oldCompressedFile.delete();
	File oldDecompressedFile = new File( "decompressed.txt" );
	oldDecompressedFile.delete();

	// open an empty File object
	File compressedFile = new File( "compressed.txt" );

	// create a CompressionUtility object with "com.topcoder.util.compression.LZ77Codec" and the emtpy File
	CompressionUtility cuCom = new CompressionUtility( codecName, compressedFile );

	// open a pre-prepared File object
	File inFile = new File( "input.txt" );
	
	// run CompressionUtility.compress( File )
	cuCom.compress( inFile );
	cuCom.close();

	// open an empty File object
	File decompressedFile = new File( "decompressed.txt" );

	// create a CompressionUtility object with "com.topcoder.util.compression.LZ77Codec" and the emtpy File
	CompressionUtility cuDec = new CompressionUtility( codecName, decompressedFile );

	// run CompressionUtility.decompress( File )
	cuDec.decompress( compressedFile );
	cuDec.close();

	// verify that their lengths are the same
	assertTrue( inFile.length() == decompressedFile.length() );

	// verify that their contents are identical
	InputStream isIn = new FileInputStream( inFile );
	InputStream isCheck = new FileInputStream( decompressedFile );
	for ( int i = 0; i < inFile.length(); i++ ) {
	    int byteIn = isIn.read();
	    int byteCheck = isCheck.read();
	    assertTrue( byteIn == byteCheck );
	}
    }

    public static void doTestStringBufferCompress( String codecName ) throws Exception {
	// open an empty StringBuffer object
	StringBuffer compressedSB = new StringBuffer();

	// create a CompressionUtility object with the emtpy StringBuffer
	CompressionUtility cuCom = new CompressionUtility( codecName, compressedSB );

	// declare the input StringBuffer object
	StringBuffer inSB = new StringBuffer();
	for ( int i = 0; i < 40; i++ ) {
	    inSB.append( "this is test text.  blah blah blah blah.  blah blah blah blah.  blah blah blah blah." );
	}
	
	// run CompressionUtility.compress( StringBuffer )
	cuCom.compress( inSB );

	// open an empty StringBuffer object
	StringBuffer decompressedSB = new StringBuffer();

	// create a CompressionUtility object with the emtpy StringBuffer
	CompressionUtility cuDec = new CompressionUtility( codecName, decompressedSB );

	// run CompressionUtility.decompress( StringBuffer )
	cuDec.decompress( compressedSB );

	// verify that their lengths are the same
	assertTrue( inSB.length() == decompressedSB.length() );

	// verify that their contents are identical
	assertTrue( inSB.toString().equals( decompressedSB.toString() ) );
    }

    public static void doTestStreamCompress( String codecName ) throws Exception{
	// open an empty StringBuffer object
	ByteArrayOutputStream compressedOS = new ByteArrayOutputStream();

	// create a CompressionUtility object with the emtpy StringBuffer
	CompressionUtility cuCom = new CompressionUtility( codecName, compressedOS );

	// declare the input Stream object
	StringBuffer inSB = new StringBuffer();
	for ( int i = 0; i < 40; i++ ) {
	    inSB.append( "this is test text.  blah blah blah blah.  blah blah blah blah.  blah blah blah blah.");
	}
	byte[] inBytes = inSB.toString().getBytes();
	ByteArrayInputStream inIS = new ByteArrayInputStream( inBytes );
	
	// run CompressionUtility.compress( InputStream )
	cuCom.compress( inIS );

	// open an empty StringBuffer object
	ByteArrayOutputStream decompressedOS = new ByteArrayOutputStream();

	// create a CompressionUtility object with the emtpy StringBuffer
	CompressionUtility cuDec = new CompressionUtility( codecName, decompressedOS );

	// run CompressionUtility.decompress( InputStream )
	cuDec.decompress( new ByteArrayInputStream( compressedOS.toByteArray() ) );

	// verify that their lengths are the same
	byte[] checkBytes = decompressedOS.toByteArray();
	assertTrue( inBytes.length == checkBytes.length );

	// verify that their contents are identical
	for ( int i = 0; i < inBytes.length; i++ ) {
	    assertTrue( inBytes[i] == checkBytes[i] );
	}
    }

}
package com.topcoder.util.compression.functionaltests;

import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

import java.io.*;
import com.topcoder.util.compression.*;

/**
 * <p>This test case aggregates all functional test cases.</p>
 *
 * @author TopCoder Software
 * @version 1.0
 */
public class FunctionalTests extends TestCase {

    public static Test suite() {
        final TestSuite suite = new TestSuite();
        suite.addTestSuite(CompressionTests.class);
        return suite;
    }

    /* MOVED TO CompressionTests.java
    public static void testFileCompressWithLZ77() throws Exception {
	doTestFileCompress( "com.topcoder.util.compression.LZ77Codec" );
    }

    public static void testFileCompressWithDefault() throws Exception {
	doTestFileCompress( "com.topcoder.util.compression.DefaultCodec" );
    }

    public static void testStringBufferCompressWithLZ77() throws Exception {
	doTestStringBufferCompress( "com.topcoder.util.compression.LZ77Codec" );
    }

    public static void testStringBufferCompressWithDefault() throws Exception {
	doTestStringBufferCompress( "com.topcoder.util.compression.DefaultCodec" );
    }

    public static void testStreamCompressWithLZ77() throws Exception {
	doTestStreamCompress( "com.topcoder.util.compression.LZ77Codec" );
    }

    public static void testStreamCompressWithDefault() throws Exception {
	doTestStreamCompress( "com.topcoder.util.compression.DefaultCodec" );
    }


    public static void doTestFileCompress( String codecName ) throws Exception {
	// delete old files
	File oldCompressedFile = new File( "compressed.txt" );
	oldCompressedFile.delete();
	File oldDecompressedFile = new File( "decompressed.txt" );
	oldDecompressedFile.delete();

	// open an empty File object
	File compressedFile = new File( "compressed.txt" );

	// create a CompressionUtility object with "com.topcoder.util.compression.LZ77Codec" and the emtpy File
	CompressionUtility cuCom = new CompressionUtility( codecName, compressedFile );

	// open a pre-prepared File object
	File inFile = new File( "input.txt" );
	
	// run CompressionUtility.compress( File )
	cuCom.compress( inFile );
	cuCom.close();

	// open an empty File object
	File decompressedFile = new File( "decompressed.txt" );

	// create a CompressionUtility object with "com.topcoder.util.compression.LZ77Codec" and the emtpy File
	CompressionUtility cuDec = new CompressionUtility( codecName, decompressedFile );

	// run CompressionUtility.decompress( File )
	cuDec.decompress( compressedFile );
	cuDec.close();

	// verify that their lengths are the same
	assertTrue( inFile.length() == decompressedFile.length() );

	// verify that their contents are identical
	InputStream isIn = new FileInputStream( inFile );
	InputStream isCheck = new FileInputStream( decompressedFile );
	for ( int i = 0; i < inFile.length(); i++ ) {
	    int byteIn = isIn.read();
	    int byteCheck = isCheck.read();
	    assertTrue( byteIn == byteCheck );
	}
    }

    public static void doTestStringBufferCompress( String codecName ) {
	// open an empty StringBuffer object
	StringBuffer compressedSB = new StringBuffer();

	// create a CompressionUtility object with the emtpy StringBuffer
	CompressionUtility cuCom = new CompressionUtility( codecName, compressedSB );

	// declare the input StringBuffer object
	StringBuffer inSB = new StringBuffer( "this is test text.  blah blah blah blah.  blah blah blah blah.  blah blah blah blah." );
	for ( int i = 0; i < 40; i++ ) {
	    inSB.append( inSB.toString() );
	}
	
	// run CompressionUtility.compress( StringBuffer )
	cuCom.compress( inSB );

	// open an empty StringBuffer object
	StringBuffer decompressedSB = new StringBuffer();

	// create a CompressionUtility object with the emtpy StringBuffer
	CompressionUtility cuDec = new CompressionUtility( codecName, decompressedSB );

	// run CompressionUtility.decompress( StringBuffer )
	cuDec.decompress( compressedSB );

	// verify that their lengths are the same
	assertTrue( inSB.length() == decompressedSB.length() );

	// verify that their contents are identical
	assertTrue( inSB.toString().equals( decompressedSB.toString() ) );
    }

    public static void doTestStreamCompress( String codecName ) {
	// open an empty StringBuffer object
	ByteArrayOutputStream compressedOS = new ByteArrayOutputStream();

	// create a CompressionUtility object with the emtpy StringBuffer
	CompressionUtility cuCom = new CompressionUtility( codecName, compressedOS );

	// declare the input Stream object
	StringBuffer inSB = new StringBuffer( "this is test text.  blah blah blah blah.  blah blah blah blah.  blah blah blah blah." );
	for ( int i = 0; i < 40; i++ ) {
	    inSB.append( inSB.toString() );
	}
	byte[] inBytes = inSB.toString().getBytes();
	ByteArrayInputStream inIS = new ByteArrayInputStream( inBytes );
	
	// run CompressionUtility.compress( InputStream )
	cuCom.compress( inIS );

	// open an empty StringBuffer object
	ByteArrayOutputStream decompressedOS = new ByteArrayOutputStream();

	// create a CompressionUtility object with the emtpy StringBuffer
	CompressionUtility cuDec = new CompressionUtility( codecName, decompressedOS );

	// run CompressionUtility.decompress( InputStream )
	cuDec.decompress( new ByteArrayInputStream( compressedOS.toByteArray() ) );

	// verify that their lengths are the same
	byte[] checkBytes = decompressedOS.toByteArray();
	assertTrue( inBytes.length == checkBytes.length );

	// verify that their contents are identical
	for ( int i = 0; i < inBytes.length; i++ ) {
	    assertTrue( inBytes[i] == checkBytes[i] );
	}
    }
    */

}
package com.topcoder.util.compression.stresstests;

import com.topcoder.util.compression.*;
import junit.framework.TestCase;
import java.util.Random;
import java.io.*;
import java.lang.reflect.Array;
import java.util.*;

/**
 * This class tests the performance of the codecs when handling random data.
 * @author nrogers
 * @version 1.0
 *
 */
public class RandomDataTest extends TestCase {
	static final int size = 100000;
	byte[] original;
	public void setUp() {
		original = new byte[size];
		Random rand = new Random(42);
		rand.nextBytes(original);
	}
	
	public void testDefaultCodec() throws Exception {
		//Test JDK supplied codec
		System.out.println("Statistics for DefaultCodec with random data:");
		doTest("com.topcoder.util.compression.DefaultCodec");
	}

	public void testLZ77Codec() throws Exception {
		//Test component supplied codec
		System.out.println("Statistics for LZ77Codec with random data:");
		doTest("com.topcoder.util.compression.LZ77Codec");
	}
	
	private void doTest(String codec) throws Exception {
		Date start, end;

		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		CompressionUtility comp = new CompressionUtility(codec, outputStream);
		ByteArrayInputStream inputStream = new ByteArrayInputStream(original);
		start = new Date();
		comp.compress(inputStream);
		end = new Date();
		System.out.println("\tCompression took " + (end.getTime()-start.getTime()) + " milliseconds.");

		byte[] compressed = outputStream.toByteArray();
		double percentage = Math.round(100.0 * compressed.length / original.length);
		System.out.println("\tCompressed data is " + percentage + " percent of the original size.");

		outputStream = new ByteArrayOutputStream();
		comp = new CompressionUtility(codec, outputStream);		
		inputStream = new ByteArrayInputStream(compressed);
		start = new Date();
		comp.decompress(inputStream);
		end = new Date();
		byte[] decompressed = outputStream.toByteArray();
		System.out.println("\tDecompression took " + (end.getTime()-start.getTime()) + " milliseconds.");
		assertTrue(Arrays.equals(original, decompressed));
	}
}
package com.topcoder.util.compression.stresstests;

import com.topcoder.util.compression.*;
import junit.framework.TestCase;
import java.util.Random;
import java.io.*;
import java.lang.reflect.Array;
import java.nio.ByteBuffer;
import java.util.*;

/**
 * This class tests the performance of the codecs when handling random data.
 * @author nrogers
 * @version 1.0
 *
 */
public class SourceCodeTest extends TestCase {
	static final int copies = 1;
	byte[] original;
	public void setUp() throws FileNotFoundException, IOException {
		FileInputStream in = new FileInputStream("test_files/input.java");
		byte[] buffer = new byte[1000];
		int bytesRead;
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		while((bytesRead = in.read(buffer)) > 0)
			out.write(buffer, 0, bytesRead);
		original = out.toByteArray();	
	}
	
	public void testDefaultCodec() throws Exception {
		//Test JDK supplied codec
		System.out.println("Statistics for DefaultCodec with source code:");
		doTest("com.topcoder.util.compression.DefaultCodec");
	}

	public void testLZ77Codec() throws Exception {
		//Test component supplied codec
		System.out.println("Statistics for LZ77Codec with source code:");
		doTest("com.topcoder.util.compression.LZ77Codec");
	}
	
	private void doTest(String codec) throws Exception {
		Date start, end;

		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		CompressionUtility comp = new CompressionUtility(codec, outputStream);
		ByteArrayInputStream inputStream = new ByteArrayInputStream(original);
		start = new Date();
		comp.compress(inputStream);
		end = new Date();
		System.out.println("\tCompression took " + (end.getTime()-start.getTime()) + " milliseconds.");

		byte[] compressed = outputStream.toByteArray();
		double percentage = Math.round(100.0 * compressed.length / original.length);
		System.out.println("\tCompressed data is " + percentage + " percent of the original size.");

		outputStream = new ByteArrayOutputStream();
		comp = new CompressionUtility(codec, outputStream);		
		inputStream = new ByteArrayInputStream(compressed);
		start = new Date();
		comp.decompress(inputStream);
		end = new Date();
		byte[] decompressed = outputStream.toByteArray();
		System.out.println("\tDecompression took " + (end.getTime()-start.getTime()) + " milliseconds.");
		assertTrue(Arrays.equals(original, decompressed));
	}
}
package com.topcoder.util.compression.stresstests;

import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

import com.topcoder.util.compression.*;

/**
 * @author nrogers
 * @version 1.0
 *
 */
public class StressTests extends TestCase {
    public static Test suite() {	
        final TestSuite suite = new TestSuite();
        suite.addTestSuite(RandomDataTest.class);
        suite.addTestSuite(SourceCodeTest.class);
        return suite;
    }

}
